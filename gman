#!/bin/bash

# gman - Go Version Manager (goverman)
# A unified tool for managing multiple Go versions
# 
# Usage: gman <command> [options]
# Commands:
#   bootstrap [version]                      Install Go on a fresh system
#   install <version> [method] [--default]   Install a Go version
#   uninstall <version>                      Uninstall a Go version
#   uninstall-all                            Uninstall all gman-managed versions
#   list                                     List installed Go versions
#   list-available [--all]                   List available Go versions
#   set-default <version>                    Set a version as the default 'go' command
#   version                                  Show gman version
#   help                                     Show this help message

set -e

# Version information
GMAN_VERSION="v1.13.0"

# Function to display usage
show_usage() {
    echo "gman - Go Version Manager (goverman)"
    echo ""
    echo "Usage: gman <command> [options]"
    echo ""
    echo "Commands:"
    echo "  bootstrap [version]                      Install Go on a fresh system (no Go required)"
    echo "  install <version> [method] [--default]   Install a Go version"
    echo "  uninstall <version>                      Uninstall a Go version"
    echo "  uninstall-all                            Uninstall all Go versions installed by gman"
    echo "  list                                     List installed Go versions"
    echo "  list-available [--all]                   List available Go versions to install"
    echo "  set-default <version>                    Set a version as the default 'go' command"
    echo "  version                                  Show gman version"
    echo "  help                                     Show this help message"
    echo ""
    echo "Bootstrap options:"
    echo "  version    Go version to install (defaults to latest stable)"
    echo "             Use 'latest' to explicitly fetch the latest version"
    echo ""
    echo "Install options:"
    echo "  version    Go version to install (e.g., 1.23.9, 1.21.5, or 'latest')"
    echo "  method     Installation method: 'official' (default) or 'direct'"
    echo "  --default  Set this version as the default 'go' command after installation"
    echo ""
    echo "Methods:"
    echo "  official   Use 'go install golang.org/dl/goX.Y.Z@latest' (recommended)"
    echo "  direct     Download and extract binary directly (fallback for ARM64 issues)"
    echo ""
    echo "Examples:"
    echo "  gman bootstrap                           # Install latest Go on fresh system"
    echo "  gman bootstrap latest                    # Explicitly install latest Go version"
    echo "  gman bootstrap 1.23.9                    # Install specific Go version on fresh system"
    echo "  gman install latest                      # Install latest Go version"
    echo "  gman install latest --default            # Install latest and set as default"
    echo "  gman install 1.23.9                      # Install using official method"
    echo "  gman install 1.23.9 direct               # Install using direct binary download"
    echo "  gman install 1.21.5 official --default   # Install and set as default"
    echo "  gman uninstall 1.21.5                    # Uninstall a Go version"
    echo "  gman uninstall-all                       # Uninstall all gman-managed versions"
    echo "  gman set-default 1.21.5                  # Set existing version as default"
    echo "  gman list                                # List all installed versions"
    echo "  gman list-available                      # List recent available versions (top 20)"
    echo "  gman list-available --all                # List all available versions"
    echo "  gman version                             # Show gman version"
    exit 0
}

# Function to show version
show_version() {
    # Try to get version from git if in a git repository
    if [[ -d .git ]] || git rev-parse --git-dir > /dev/null 2>&1; then
        local git_version=$(git describe --tags --always --dirty 2>/dev/null)
        if [[ -n "$git_version" ]]; then
            echo "gman $git_version"
        else
            echo "gman $GMAN_VERSION"
        fi
    else
        echo "gman $GMAN_VERSION"
    fi
}

# Function to detect architecture
detect_arch() {
    local arch=$(uname -m)
    case $arch in
        x86_64)
            echo "amd64"
            ;;
        aarch64|arm64)
            echo "arm64"
            ;;
        armv7l)
            echo "armv6l"
            ;;
        *)
            echo "Unsupported architecture: $arch" >&2
            exit 1
            ;;
    esac
}

# Function to detect Linux distribution
detect_linux_distro() {
    if [[ -f /etc/os-release ]]; then
        # Most modern Linux distributions have /etc/os-release
        . /etc/os-release
        echo "${ID:-unknown}"
    elif [[ -f /etc/slackware-version ]]; then
        echo "slackware"
    elif [[ -f /etc/redhat-release ]]; then
        # Older RHEL-based systems
        if grep -q "AlmaLinux" /etc/redhat-release; then
            echo "almalinux"
        elif grep -q "CentOS" /etc/redhat-release; then
            echo "centos"
        elif grep -q "Red Hat" /etc/redhat-release; then
            echo "rhel"
        else
            echo "rhel-based"
        fi
    elif [[ -f /etc/alpine-release ]]; then
        echo "alpine"
    else
        echo "unknown"
    fi
}

# Function to detect if using musl libc (Alpine Linux)
detect_musl() {
    # Check if ldd exists and check for musl
    if command -v ldd >/dev/null 2>&1; then
        if ldd --version 2>&1 | grep -q musl; then
            echo "true"
            return
        fi
    fi
    
    # Check if /etc/alpine-release exists
    if [[ -f /etc/alpine-release ]]; then
        echo "true"
        return
    fi
    
    # Check if apk package manager exists (Alpine's package manager)
    if command -v apk >/dev/null 2>&1; then
        echo "true"
        return
    fi
    
    echo "false"
}

# Function to detect OS
detect_os() {
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    # Debug output for GitHub Actions
    if [[ -n "$GITHUB_ACTIONS" ]]; then
        echo "Debug: Detected OS string: '$os'" >&2
    fi
    case $os in
        linux)
            echo "linux"
            ;;
        darwin)
            echo "darwin"
            ;;
        mingw*|msys*|cygwin*)
            echo "windows"
            ;;
        *)
            echo "Unsupported OS: $os" >&2
            exit 1
            ;;
    esac
}

# Function to get latest stable Go version
get_latest_go_version() {
    local url="https://go.dev/dl/"
    local temp_file=$(mktemp)
    local download_status=1
    
    # Check if we have curl or wget
    if command -v curl >/dev/null 2>&1; then
        if curl -sL "$url" > "$temp_file" 2>&1; then
            download_status=0
        else
            # In CI, provide more details
            if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]]; then
                echo "Debug: curl failed to download $url" >&2
            fi
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -qO "$temp_file" "$url" 2>&1; then
            download_status=0
        else
            # In CI, provide more details
            if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]]; then
                echo "Debug: wget failed to download $url" >&2
            fi
        fi
    else
        echo "Error: Neither curl nor wget is available" >&2
        rm -f "$temp_file"
        return 1
    fi
    
    # Check if download succeeded
    if [[ $download_status -ne 0 ]] || [[ ! -s "$temp_file" ]]; then
        if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]]; then
            echo "Debug: Failed to download Go versions page (network issue?)" >&2
        fi
        rm -f "$temp_file"
        return 1
    fi
    
    # Extract the first stable version (not rc or beta)
    local latest=$(grep -oE 'go[0-9]+\.[0-9]+\.[0-9]+' "$temp_file" | grep -v -E 'rc|beta' | head -1)
    rm -f "$temp_file"
    
    if [[ -z "$latest" ]]; then
        echo "Error: Could not determine latest Go version" >&2
        return 1
    fi
    
    # Remove 'go' prefix
    echo "${latest#go}"
}

# Function to bootstrap Go installation
bootstrap_go() {
    local version="$1"
    
    echo "Go Bootstrap Installer"
    echo "====================="
    echo ""
    
    # Check if Go is already installed
    if command -v go >/dev/null 2>&1; then
        # Check if go command actually works
        if go version >/dev/null 2>&1; then
            echo "Go is already installed on this system:"
            echo "  Version: $(go version)"
            echo "  Location: $(which go)"
            echo ""
            echo "The bootstrap command is meant for fresh systems without Go."
            echo "Use 'gman install <version>' to install additional Go versions."
            exit 0
        else
            echo "Warning: Go command exists but is not working properly"
            echo "  Location: $(which go)"
            echo "  Error: $(go version 2>&1 || echo "Failed to run go version")"
            echo ""
            echo "This appears to be a broken Go installation."
            echo "Proceeding with bootstrap to install a working Go..."
            echo ""
        fi
    fi
    
    # If no version specified or "latest" is used, get latest
    if [[ -z "$version" ]] || [[ "$version" == "latest" ]]; then
        if [[ "$version" == "latest" ]]; then
            echo "Fetching latest stable version..."
        else
            echo "No version specified, fetching latest stable version..."
        fi
        version=$(get_latest_go_version)
        if [[ $? -ne 0 ]]; then
            echo "Failed to fetch latest version. Please specify a version manually."
            echo "Example: gman bootstrap 1.23.9"
            exit 1
        fi
        echo "Latest stable version: $version"
        echo ""
    fi
    
    # Validate version format
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "Error: Invalid version format '$version'. Use format like '1.23.9'"
        exit 1
    fi
    
    local os=$(detect_os)
    local arch=$(detect_arch)
    local is_musl=$(detect_musl)
    local extension="tar.gz"
    
    # Windows uses zip files
    if [[ "$os" == "windows" ]]; then
        extension="zip"
    fi
    
    # Construct filename
    local filename="go${version}.${os}-${arch}.${extension}"
    local url="https://go.dev/dl/${filename}"
    
    echo "Installing Go ${version}..."
    echo "=========================="
    echo "OS: $os"
    if [[ "$os" == "linux" ]]; then
        local distro=$(detect_linux_distro)
        echo "Distribution: $distro"
    fi
    echo "Architecture: $arch"
    echo "Download URL: $url"
    echo ""
    
    # Create temporary directory
    local temp_dir=$(mktemp -d)
    trap "rm -rf $temp_dir" EXIT
    
    # Download Go
    echo "Downloading $filename..."
    local download_status=1
    
    if command -v curl >/dev/null 2>&1; then
        echo "Using curl..."
        if curl -L --progress-bar -o "$temp_dir/$filename" "$url"; then
            download_status=0
        fi
    elif command -v wget >/dev/null 2>&1; then
        echo "Using wget..."
        if wget -q --show-progress -O "$temp_dir/$filename" "$url"; then
            download_status=0
        fi
    else
        echo "Error: Neither curl nor wget is available"
        echo "Please install curl or wget first"
        exit 1
    fi
    
    if [[ $download_status -ne 0 ]]; then
        echo "Error: Failed to download Go $version"
        exit 1
    fi
    
    echo "✓ Download completed"
    
    # Install to /usr/local/go (standard location)
    local install_dir="/usr/local/go"
    echo ""
    echo "Installing to $install_dir..."
    echo ""
    
    # Check if we need sudo
    local use_sudo=""
    if [[ ! -w "/usr/local" ]]; then
        if command -v sudo >/dev/null 2>&1; then
            echo "Installation requires administrator privileges."
            echo "You may be prompted for your password."
            use_sudo="sudo"
        else
            echo "Error: Cannot write to /usr/local and sudo is not available"
            echo "Please run this command as root or install sudo"
            exit 1
        fi
    fi
    
    # Remove existing installation if present
    if [[ -d "$install_dir" ]]; then
        echo "Removing existing installation at $install_dir..."
        $use_sudo rm -rf "$install_dir"
    fi
    
    # Extract Go
    echo "Extracting Go ${version}..."
    if [[ "$os" == "windows" ]]; then
        # For Windows, use unzip
        if command -v unzip >/dev/null 2>&1; then
            $use_sudo unzip -q "$temp_dir/$filename" -d "/usr/local"
        else
            echo "Error: unzip is required for Windows installation"
            exit 1
        fi
    else
        # For Unix-like systems, use tar
        $use_sudo tar -C "/usr/local" -xzf "$temp_dir/$filename"
    fi
    
    echo "✓ Go installed to $install_dir"
    
    # Setup PATH
    echo ""
    echo "Setting up PATH..."
    local profile_file=$(get_shell_profile)
    local shell_name=$(detect_shell)
    local path_export_line='export PATH="/usr/local/go/bin:$PATH"'
    local path_marker="# Added by goverman bootstrap"
    
    if [[ -n "$profile_file" ]]; then
        # Check if already in profile
        if [[ -f "$profile_file" ]] && grep -q "/usr/local/go/bin" "$profile_file" 2>/dev/null; then
            echo "✓ /usr/local/go/bin already in $profile_file"
        else
            echo ""
            echo "Adding /usr/local/go/bin to PATH in $profile_file..."
            
            # Create profile file if it doesn't exist
            if [[ ! -f "$profile_file" ]]; then
                touch "$profile_file"
            fi
            
            # Add PATH export
            echo "" >> "$profile_file"
            echo "$path_marker" >> "$profile_file"
            echo "$path_export_line" >> "$profile_file"
            
            echo "✓ Added to PATH in $profile_file"
        fi
    fi
    
    # Also update current session
    export PATH="/usr/local/go/bin:$PATH"
    
    echo ""
    echo "========================================="
    echo "✅ Go ${version} successfully installed!"
    echo "========================================="
    echo ""
    echo "Installation details:"
    echo "  Location: $install_dir"
    echo "  Binary: /usr/local/go/bin/go"
    echo "  Version: $(go version 2>/dev/null || echo "Please restart your terminal")"
    echo ""
    echo "Next steps:"
    echo "  1. Restart your terminal or run: source $profile_file"
    echo "  2. Verify installation: go version"
    echo "  3. Install additional versions: gman install <version>"
    echo ""
    echo "Now you can use gman to manage multiple Go versions!"
}

# Function to check if Go is installed
check_go_installed() {
    if ! command -v go >/dev/null 2>&1; then
        echo "Error: Go is not installed."
        echo ""
        echo "To install Go on this system, use:"
        echo "  gman bootstrap              # Install latest stable Go"
        echo "  gman bootstrap 1.23.9       # Install specific version"
        echo ""
        echo "Or visit: https://go.dev/doc/install"
        exit 1
    fi
    
    # Check if go command actually works (not just exists)
    if ! go version >/dev/null 2>&1; then
        echo "Error: Go command exists but is not working properly."
        echo "This may be due to a broken installation or PATH issues."
        echo ""
        echo "To fix this, you can:"
        echo "  1. Use 'gman bootstrap' to install a fresh Go"
        echo "  2. Fix your existing Go installation"
        echo "  3. Check your PATH environment variable"
        exit 1
    fi
    
    echo "✓ Go is installed: $(go version)"
}

# Function to detect user's shell
detect_shell() {
    local shell_name=""
    
    # Use the SHELL environment variable which represents the user's default shell
    # This is more reliable than checking the current process since the script
    # runs in bash regardless of the user's shell
    if [[ -n "$SHELL" ]]; then
        shell_name=$(basename "$SHELL")
    else
        # Fallback: check passwd file for user's default shell
        local user_shell=""
        if command -v getent >/dev/null 2>&1; then
            user_shell=$(getent passwd "$USER" | cut -d: -f7)
        elif [[ -f /etc/passwd ]]; then
            user_shell=$(grep "^$USER:" /etc/passwd | cut -d: -f7)
        fi
        if [[ -n "$user_shell" ]]; then
            shell_name=$(basename "$user_shell")
        else
            # Last resort: try parent process
            local ppid_shell=$(ps -p $PPID -o comm= 2>/dev/null | sed 's/^-//')
            if [[ -n "$ppid_shell" ]]; then
                shell_name="$ppid_shell"
            fi
        fi
    fi
    
    echo "$shell_name"
}

# Function to get shell profile file
get_shell_profile() {
    local shell_name=$(detect_shell)
    local profile_file=""
    
    case "$shell_name" in
        bash)
            if [[ -f "$HOME/.bashrc" ]]; then
                profile_file="$HOME/.bashrc"
            elif [[ -f "$HOME/.bash_profile" ]]; then
                profile_file="$HOME/.bash_profile"
            fi
            ;;
        zsh)
            if [[ -f "$HOME/.zshrc" ]]; then
                profile_file="$HOME/.zshrc"
            elif [[ -f "$HOME/.zprofile" ]]; then
                profile_file="$HOME/.zprofile"
            fi
            ;;
        fish)
            profile_file="$HOME/.config/fish/config.fish"
            ;;
        *)
            # Default to .profile for unknown shells
            profile_file="$HOME/.profile"
            ;;
    esac
    
    echo "$profile_file"
}

# Function to add PATH to shell profile
add_to_shell_profile() {
    local gobin="$1"
    local profile_file=$(get_shell_profile)
    local shell_name=$(detect_shell)
    
    if [[ -z "$profile_file" ]]; then
        echo "Warning: Could not determine shell profile file" >&2
        return 1
    fi
    
    # Check if PATH export already exists
    local path_export_line="export PATH=\"$gobin:\$PATH\""
    local path_marker="# Added by goverman"
    
    # Check if already added
    if [[ -f "$profile_file" ]] && grep -q "$gobin" "$profile_file" 2>/dev/null; then
        echo "✓ $gobin already in $profile_file" >&2
        return 0
    fi
    
    echo "" >&2
    echo "Detected shell: $shell_name" >&2
    
    # Check if we're in CI/non-interactive mode
    if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ ! -t 0 ]]; then
        echo "Running in non-interactive mode (CI detected). Skipping PATH setup." >&2
        echo "To add to PATH manually, add this to $profile_file:" >&2
        echo "  $path_export_line" >&2
        return
    fi
    
    echo "Would you like to add $gobin to your PATH permanently?" >&2
    echo "This will add the following line to $profile_file:" >&2
    echo "  $path_export_line" >&2
    read -p "Add to PATH? (y/N): " -n 1 -r
    echo >&2
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Create profile file if it doesn't exist
        if [[ ! -f "$profile_file" ]]; then
            touch "$profile_file"
        fi
        
        # Add PATH export with marker comment
        echo "" >> "$profile_file"
        echo "$path_marker" >> "$profile_file"
        echo "$path_export_line" >> "$profile_file"
        
        echo "✓ Added $gobin to PATH in $profile_file" >&2
        echo "" >&2
        echo "To use it in the current session, run:" >&2
        echo "  source $profile_file" >&2
        echo "Or restart your terminal." >&2
    else
        echo "Skipped adding to PATH permanently." >&2
    fi
}

# Function to setup Go binary path
setup_go_path() {
    local gopath=""
    local gobin_env=""
    local gobin
    
    # Try to get Go environment, but handle broken installations
    if command -v go >/dev/null 2>&1 && go version >/dev/null 2>&1; then
        gopath=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
        gobin_env=$(go env GOBIN 2>/dev/null || echo "")
    else
        # Go is broken or not installed, use defaults
        gopath="$HOME/go"
        gobin_env=""
    fi
    
    # Use GOBIN if set and not empty, otherwise use GOPATH/bin
    if [[ -n "$gobin_env" ]]; then
        gobin="$gobin_env"
    else
        gobin="$gopath/bin"
    fi
    
    # Create bin directory if it doesn't exist
    mkdir -p "$gobin"
    
    # Check if Go bin is in PATH
    if [[ ":$PATH:" != *":$gobin:"* ]]; then
        echo "Warning: $gobin is not in your PATH" >&2
        
        # Temporarily add to PATH for this session
        export PATH="$gobin:$PATH"
        echo "✓ Temporarily added $gobin to PATH for this session" >&2
        
        # Offer to add permanently
        add_to_shell_profile "$gobin"
    else
        echo "✓ Go bin directory is in PATH" >&2
    fi
    
    echo "$gobin"
}

# Function to install via official method
install_official() {
    local version="$1"
    local go_binary="go${version}"
    local is_musl=$(detect_musl)
    
    echo "Installing Go ${version} using official method..."
    echo "================================================="
    
    # Check if we're on Alpine Linux
    if [[ "$is_musl" == "true" ]]; then
        echo "Note: Detected Alpine Linux (musl libc)."
        echo "The official method may have limited compatibility on Alpine."
        echo "If you encounter issues, try the direct method instead."
        echo ""
    fi
    
    # Try with CGO enabled first
    echo "Attempting installation with CGO enabled..."
    local install_output
    install_output=$(go install "golang.org/dl/go${version}@latest" 2>&1)
    local install_status=$?
    
    if [[ $install_status -eq 0 ]]; then
        echo "✓ Installation successful with CGO enabled"
    else
        # Check for known error patterns
        if echo "$install_output" | grep -q "undefined: signalsToIgnore"; then
            echo "Error: Known compatibility issue with golang.org/dl"
            echo "This is a known issue when installing older Go versions with newer base Go."
            echo "Please use the direct method instead: gman install $version direct"
            exit 1
        fi
        
        echo "Installation failed with CGO enabled, trying with CGO disabled..."
        install_output=$(CGO_ENABLED=0 go install "golang.org/dl/go${version}@latest" 2>&1)
        install_status=$?
        
        if [[ $install_status -eq 0 ]]; then
            echo "✓ Installation successful with CGO disabled"
        else
            # Check again for the known error pattern
            if echo "$install_output" | grep -q "undefined: signalsToIgnore"; then
                echo "Error: Known compatibility issue with golang.org/dl"
                echo "This is a known issue when installing older Go versions with newer base Go."
                echo "Please use the direct method instead: gman install $version direct"
                exit 1
            fi
            echo "Error: Official installation method failed"
            echo "Error output: $install_output"
            echo "Try using the direct method: gman install $version direct"
            exit 1
        fi
    fi
    
    # Get the actual install location
    local gobin=$(setup_go_path)
    local install_target
    
    # Check multiple possible locations
    if [[ -f "$gobin/$go_binary" ]]; then
        install_target="$gobin/$go_binary"
    elif [[ -f "$HOME/go/bin/$go_binary" ]]; then
        install_target="$HOME/go/bin/$go_binary"
        gobin="$HOME/go/bin"
    else
        # Try to find where go install actually put it
        echo "Searching for installed binary..."
        install_target=$(find "$HOME" -name "$go_binary" -type f -executable 2>/dev/null | head -1)
        if [[ -n "$install_target" ]]; then
            gobin=$(dirname "$install_target")
            echo "Found binary at: $install_target"
        fi
    fi
    
    # Verify binary was installed
    if [[ -z "$install_target" || ! -f "$install_target" ]]; then
        echo "Error: Binary $go_binary not found after installation"
        echo "Debug info:"
        echo "  Expected: $gobin/$go_binary" 
        if command -v go >/dev/null 2>&1 && go version >/dev/null 2>&1; then
            echo "  GOPATH: $(go env GOPATH)"
            echo "  GOBIN: $(go env GOBIN)"
        else
            echo "  GOPATH: $HOME/go (default, Go not working)"
            echo "  GOBIN: (not set, Go not working)"
        fi
        echo "  Directory contents of $gobin:"
        ls -la "$gobin/" 2>/dev/null || echo "  Directory doesn't exist"
        echo "  Searching for $go_binary in home directory:"
        find "$HOME" -name "$go_binary" -type f 2>/dev/null || echo "  Not found"
        exit 1
    fi
    
    echo "✓ Binary installed: $install_target"
    
    # Download the Go version
    echo ""
    echo "Downloading Go ${version}..."
    
    # Make sure the binary directory is in PATH
    export PATH="$gobin:$PATH"
    
    if "$install_target" download; then
        echo "✓ Go ${version} downloaded successfully"
    else
        echo "Error: Failed to download Go ${version}"
        echo "Binary path: $install_target"
        echo "Binary exists: $(test -f "$install_target" && echo "yes" || echo "no")"
        echo "Binary executable: $(test -x "$install_target" && echo "yes" || echo "no")"
        echo ""
        echo "The binary was installed but the SDK download failed."
        echo "This is a known issue with some Go versions."
        echo "Please try the direct method instead: gman install $version direct"
        
        # Clean up the non-functional binary
        echo "Cleaning up non-functional binary..."
        rm -f "$install_target"
        
        exit 1
    fi
}

# Function to install via direct method
install_direct() {
    local version="$1"
    local os=$(detect_os)
    local arch=$(detect_arch)
    local is_musl=$(detect_musl)
    local extension="tar.gz"
    
    # Windows uses zip files
    if [[ "$os" == "windows" ]]; then
        extension="zip"
    fi
    
    # Construct filename based on OS and libc type
    local filename=""
    if [[ "$os" == "linux" ]] && [[ "$is_musl" == "true" ]]; then
        # Alpine Linux uses different binary naming
        # Note: Official Go releases don't have Alpine-specific builds before Go 1.21
        # We'll try the regular Linux build first, which may work on newer Alpine versions
        filename="go${version}.${os}-${arch}.${extension}"
        echo "Note: Detected Alpine Linux (musl libc). Official Go builds may have limited compatibility."
        echo "For best results, consider using Alpine's package manager: apk add go"
    else
        filename="go${version}.${os}-${arch}.${extension}"
    fi
    
    local url="https://go.dev/dl/${filename}"
    local go_binary="go${version}"
    
    # Debug OS detection in CI
    if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        echo "Debug: Detected OS string: '$(uname -s | tr '[:upper:]' '[:lower:]')'" >&2
        echo "Debug: Musl libc detected: '$is_musl'" >&2
    fi
    
    echo "Installing Go ${version} using direct method..."
    echo "=============================================="
    echo "OS: $os"
    if [[ "$os" == "linux" ]]; then
        local distro=$(detect_linux_distro)
        echo "Distribution: $distro"
    fi
    echo "Architecture: $arch"
    echo "Musl libc (Alpine): $is_musl"
    echo "Download URL: $url"
    echo ""
    
    # Create temporary directory
    local temp_dir=$(mktemp -d)
    trap "rm -rf $temp_dir" EXIT
    
    # Download the binary
    echo "Downloading $filename..."
    local download_status=1
    local downloaded=false
    
    # Try curl first (more reliable across distributions)
    if command -v curl >/dev/null 2>&1; then
        echo "Using curl..."
        if curl -L --progress-bar -o "$temp_dir/$filename" "$url"; then
            download_status=0
            downloaded=true
        else
            download_status=$?
            echo "Warning: curl failed with status $download_status"
            # Try again with -k for SSL issues
            if [[ $download_status -eq 60 ]] || [[ $download_status -eq 77 ]]; then
                echo "Retrying with -k due to SSL error..."
                if curl -kL --progress-bar -o "$temp_dir/$filename" "$url"; then
                    download_status=0
                    downloaded=true
                    echo "✓ Download succeeded with -k (insecure)"
                fi
            fi
        fi
    fi
    
    # If curl failed or isn't available, try wget
    if [[ "$downloaded" == "false" ]] && command -v wget >/dev/null 2>&1; then
        echo "Trying wget..."
        if wget -q --show-progress -O "$temp_dir/$filename" "$url" 2>&1; then
            download_status=0
            downloaded=true
        else
            download_status=$?
            echo "Warning: wget failed with status $download_status"
            # Try again with --no-check-certificate for SSL issues
            if [[ $download_status -eq 5 ]]; then
                echo "Retrying with --no-check-certificate due to SSL error..."
                if wget --no-check-certificate -q --show-progress -O "$temp_dir/$filename" "$url" 2>&1; then
                    download_status=0
                    downloaded=true
                    echo "✓ Download succeeded with --no-check-certificate"
                fi
            fi
        fi
    fi
    
    # Check if download succeeded
    if [[ "$downloaded" == "false" ]]; then
        echo "Error: Failed to download Go $version"
        echo "URL attempted: $url"
        if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
            echo "Neither curl nor wget is available for download"
        fi
        echo "Please check your internet connection and try again"
        exit 1
    fi
    
    # Verify the downloaded file exists and is not empty
    if [[ ! -f "$temp_dir/$filename" ]] || [[ ! -s "$temp_dir/$filename" ]]; then
        echo "Error: Downloaded file is missing or empty"
        exit 1
    fi
    
    echo "✓ Download completed"
    
    # Setup paths
    local gopath=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
    local gobin=$(setup_go_path)
    local install_dir="$HOME/sdk/go${version}"
    
    # Create SDK directory
    mkdir -p "$HOME/sdk"
    
    # Extract Go
    echo "Extracting Go ${version}..."
    if [[ "$os" == "windows" ]]; then
        # For Windows, use unzip
        if command -v unzip >/dev/null 2>&1; then
            unzip -q "$temp_dir/$filename" -d "$HOME/sdk"
        else
            echo "Error: unzip is required for Windows installation"
            exit 1
        fi
    else
        # For Unix-like systems, use tar
        tar -C "$HOME/sdk" -xzf "$temp_dir/$filename"
    fi
    mv "$HOME/sdk/go" "$install_dir"
    echo "✓ Extracted to: $install_dir"
    
    # Create wrapper binary
    echo "Creating wrapper binary..."
    
    # Determine the go executable name based on OS
    local go_exe="go"
    if [[ "$os" == "windows" ]]; then
        go_exe="go.exe"
    fi
    
    # Create the wrapper script with the actual path directly
    cat > "$gobin/$go_binary" << EOF
#!/bin/bash
export GOROOT="$install_dir"
exec "$install_dir/bin/$go_exe" "\$@"
EOF
    
    chmod +x "$gobin/$go_binary"
    echo "✓ Wrapper binary created: $gobin/$go_binary"
}

# Function to verify installation
verify_installation() {
    local version="$1"
    local go_binary="go${version}"
    
    echo ""
    echo "Verifying installation..."
    echo "========================"
    
    if command -v "$go_binary" >/dev/null 2>&1; then
        echo "✓ $go_binary is accessible"
        echo "Version: $($go_binary version)"
        echo "GOROOT: $($go_binary env GOROOT)"
        echo ""
        echo "🎉 Installation completed successfully!"
        echo ""
        echo "Usage:"
        echo "  $go_binary version                    # Check version"
        echo "  $go_binary build main.go             # Build with this Go version"
        echo "  $go_binary env                       # Show environment"
    else
        echo "❌ Error: $go_binary is not accessible"
        echo "You may need to:"
        echo "  1. Restart your terminal"
        echo "  2. Add Go bin directory to your PATH"
        echo "  3. Run: source ~/.bashrc (or your shell profile)"
        exit 1
    fi
}

# Function to analyze PATH and detect conflicting Go installations
analyze_path_for_go() {
    local gobin="$1"
    local issues_found=false
    local gobin_position=-1
    local conflicting_positions=""
    local position=1
    
    # Find position of gobin and any conflicting Go installations
    IFS=':' read -ra PATH_ARRAY <<< "$PATH"
    for dir in "${PATH_ARRAY[@]}"; do
        if [[ "$dir" == "$gobin" ]]; then
            if [[ $gobin_position -eq -1 ]]; then
                gobin_position=$position
            fi
        elif [[ -x "$dir/go" ]] && [[ "$dir" != "$gobin" ]]; then
            # Found another go binary
            if [[ $gobin_position -eq -1 ]] || [[ $position -lt $gobin_position ]]; then
                conflicting_positions="$conflicting_positions $position:$dir"
                issues_found=true
            fi
        elif [[ "$dir" == "/opt/homebrew/bin" ]] && [[ -x "/opt/homebrew/bin/go" ]]; then
            # Special case for Homebrew on Apple Silicon
            if [[ $gobin_position -eq -1 ]] || [[ $position -lt $gobin_position ]]; then
                conflicting_positions="$conflicting_positions $position:$dir"
                issues_found=true
            fi
        elif [[ "$dir" == "/usr/local/bin" ]] && [[ -x "/usr/local/bin/go" ]]; then
            # Special case for Homebrew on Intel or other installs
            if [[ $gobin_position -eq -1 ]] || [[ $position -lt $gobin_position ]]; then
                conflicting_positions="$conflicting_positions $position:$dir"
                issues_found=true
            fi
        fi
        position=$((position + 1))
    done
    
    echo "$issues_found|$gobin_position|$conflicting_positions"
}

# Function to fix PATH ordering
fix_path_ordering() {
    local gobin="$1"
    local profile_file=$(get_shell_profile)
    local shell_name=$(detect_shell)
    
    # Get detailed PATH analysis
    local path_analysis=$(analyze_path_for_go "$gobin")
    local conflicting_positions=$(echo "$path_analysis" | cut -d'|' -f3)
    
    echo "" >&2
    echo "PATH Ordering Fix" >&2
    echo "=================" >&2
    echo "" >&2
    echo "Detected issues with PATH ordering:" >&2
    echo "- $gobin needs to come before other Go installations" >&2
    echo "" >&2
    echo "Conflicting Go installations found:" >&2
    for conflict in $conflicting_positions; do
        local pos=$(echo "$conflict" | cut -d':' -f1)
        local dir=$(echo "$conflict" | cut -d':' -f2)
        echo "  Position $pos: $dir" >&2
        if [[ -x "$dir/go" ]]; then
            local go_ver=$("$dir/go" version 2>/dev/null | awk '{print $3}' || echo "unknown")
            echo "    └─ $go_ver" >&2
        fi
    done
    echo "" >&2
    
    # Check if we're in CI/non-interactive mode
    if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ ! -t 0 ]]; then
        echo "Running in non-interactive mode (CI detected). Skipping PATH fix." >&2
        echo "To fix PATH ordering manually, add this to your shell profile:" >&2
        echo "  export PATH=\"$gobin:\$PATH\"" >&2
        return 0  # Don't fail in CI mode - the installation was successful
    fi
    
    echo "Would you like to fix this by prepending $gobin to your PATH?" >&2
    if [[ -n "$profile_file" ]]; then
        echo "This will update $profile_file" >&2
    else
        echo "Warning: Could not determine shell profile file" >&2
    fi
    read -p "Fix PATH ordering? (y/N): " -n 1 -r
    echo >&2
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Check if we have a valid profile file
        if [[ -z "$profile_file" ]]; then
            echo "Error: Cannot update PATH - no shell profile file found" >&2
            return 1
        fi
        
        # Remove any existing goverman PATH entries
        if [[ -f "$profile_file" ]]; then
            # Create backup
            cp "$profile_file" "$profile_file.backup.$(date +%s)"
            
            # Create temp file without goverman entries
            local temp_clean=$(mktemp)
            # Remove lines that contain "# Added by goverman" and the following line
            awk '/# Added by goverman/{getline; next} 1' "$profile_file" > "$temp_clean"
            # Also remove any standalone PATH exports for gobin
            grep -v "export PATH=\"$gobin:\$PATH\"" "$temp_clean" > "$profile_file"
            rm -f "$temp_clean"
        fi
        
        # Add new PATH entry at the END of the file
        local path_export_line="export PATH=\"$gobin:\$PATH\""
        local path_marker="# Added by goverman"
        
        # Append to the end of the file
        if [[ ! -f "$profile_file" ]]; then
            touch "$profile_file"
        fi
        
        # Add a newline if the file doesn't end with one
        if [[ -s "$profile_file" ]] && [[ $(tail -c 1 "$profile_file" | wc -l) -eq 0 ]]; then
            echo "" >> "$profile_file"
        fi
        
        # Add the PATH export at the end
        echo "" >> "$profile_file"
        echo "$path_marker" >> "$profile_file"
        echo "$path_export_line" >> "$profile_file"
        
        echo "✓ Updated $profile_file to prioritize $gobin" >&2
        echo "" >&2
        echo "To apply changes in the current session, run:" >&2
        echo "  source $profile_file" >&2
        echo "" >&2
        
        # Also update current session
        export PATH="$gobin:$PATH"
        echo "✓ Updated PATH for current session" >&2
        
        return 0
    else
        echo "Skipped PATH fix. You may need to manually adjust your PATH." >&2
        return 1
    fi
}

# Function to set a Go version as default
set_default_version() {
    local version="$1"
    local force_path_check="${2:-}"
    local go_binary="go${version}"
    local gobin=$(setup_go_path)
    
    # Check if the version exists
    if ! command -v "$go_binary" >/dev/null 2>&1; then
        echo "Error: Go version $version is not installed" >&2
        echo "Run 'gman install $version' to install it first" >&2
        return 1
    fi
    
    # Create or update the 'go' symlink in gobin
    local go_link="$gobin/go"
    
    # Check if there's already a go command in gobin
    if [[ -L "$go_link" ]]; then
        echo "Current default: $(readlink "$go_link" | xargs basename)" >&2
    elif [[ -f "$go_link" ]]; then
        if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ -n "$MSYSTEM" ]]; then
            # On Windows, this is expected - we'll overwrite the wrapper script
            if grep -q "exec.*go[0-9]" "$go_link" 2>/dev/null; then
                local current_default=$(grep "exec" "$go_link" 2>/dev/null | grep -o "go[0-9]\+\.[0-9]\+\.[0-9]\+" | head -1)
                if [[ -n "$current_default" ]]; then
                    echo "Current default: $current_default" >&2
                fi
            fi
        else
            echo "Warning: $go_link exists but is not a symlink" >&2
            echo "Please remove it manually before setting a default version" >&2
            return 1
        fi
    fi
    
    # Create the symlink or wrapper script
    if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ -n "$MSYSTEM" ]]; then
        # On Windows, create a wrapper script instead of symlink
        cat > "$go_link" << EOF
#!/bin/bash
# Default Go version managed by goverman
exec "$gobin/$go_binary" "\$@"
EOF
        chmod +x "$go_link"
    else
        # On Unix-like systems, use symlink
        cd "$gobin"
        ln -sf "$go_binary" "go"
        cd - >/dev/null
    fi
    
    echo "✓ Set go${version} as the default 'go' command" >&2
    echo "" >&2
    echo "Note: This will only work if $gobin comes before system Go in your PATH" >&2
    echo "Current PATH order:" >&2
    echo "$PATH" | tr ':' '\n' | grep -n "go" | head -5 | sed 's/^/  /' >&2
    
    # Clear command hash table to ensure we get fresh results
    hash -r 2>/dev/null || true
    
    # Verify it works
    echo "" >&2
    echo "Verification:" >&2
    echo "  which go: $(which go)" >&2
    local actual_go_version=$(go version 2>/dev/null || echo "failed")
    echo "  go version: $actual_go_version" >&2
    
    # Check if the PATH ordering is causing issues
    local expected_go_path="$gobin/go"
    local actual_go_path=$(which go 2>/dev/null)
    
    # Normalize paths for comparison on Windows
    if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ -n "$MSYSTEM" ]]; then
        # Convert Windows paths to Unix-style for comparison
        # C:\Users\... becomes /c/Users/...
        expected_go_path=$(echo "$expected_go_path" | sed 's|\\|/|g' | sed 's|C:|/c|g')
        actual_go_path=$(echo "$actual_go_path" | sed 's|\\|/|g' | sed 's|C:|/c|g')
        
        # Also handle case sensitivity
        expected_go_path=$(echo "$expected_go_path" | tr '[:upper:]' '[:lower:]')
        actual_go_path=$(echo "$actual_go_path" | tr '[:upper:]' '[:lower:]')
    fi
    
    # Always analyze PATH for conflicts when force_path_check is set
    local path_analysis=$(analyze_path_for_go "$gobin")
    local issues_found=$(echo "$path_analysis" | cut -d'|' -f1)
    
    if [[ "$actual_go_path" != "$expected_go_path" ]]; then
        echo "" >&2
        echo "⚠️  WARNING: The 'go' command is not using the goverman-managed version!" >&2
        echo "  Expected: $expected_go_path" >&2
        echo "  Actual: $actual_go_path" >&2
        
        if [[ "$issues_found" == "true" ]]; then
            echo "" >&2
            echo "This is because another Go installation appears earlier in your PATH." >&2
            
            # Offer to fix
            fix_path_ordering "$gobin"
        else
            echo "" >&2
            echo "PATH is already correctly ordered." >&2
        fi
    elif [[ "$force_path_check" == "check_path" ]] && [[ "$issues_found" == "true" ]]; then
        # Even if go points to the right place, check for conflicts when --default was used
        echo "" >&2
        echo "⚠️  Found conflicting Go installations in your PATH!" >&2
        echo "" >&2
        echo "While 'go' currently points to the goverman-managed version," >&2
        echo "there are other Go installations that could cause issues." >&2
        
        # Offer to fix
        fix_path_ordering "$gobin"
    else
        echo "✓ Go $version is now the default 'go' command" >&2
    fi
    
    return 0
}

# Function to list installed versions
list_installed_versions() {
    echo "Locally Installed Go Versions"
    echo "============================="
    
    local found_versions=0
    local seen_versions=""  # Track versions we've already seen (space-separated list)
    
    # Get gobin directory
    # Handle broken Go installations
    local gopath="$HOME/go"
    local gobin_env=""
    if command -v go >/dev/null 2>&1 && go version >/dev/null 2>&1; then
        gopath=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
        gobin_env=$(go env GOBIN 2>/dev/null || echo "")
    fi
    local gobin
    if [[ -n "$gobin_env" ]]; then
        gobin="$gobin_env"
    else
        gobin="$gopath/bin"
    fi
    
    # Check if there's a default symlink in gobin
    local default_symlink=""
    if [[ -L "$gobin/go" ]]; then
        default_symlink=$(readlink "$gobin/go" | xargs basename)
    elif [[ -f "$gobin/go" ]] && [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || -n "$MSYSTEM" ]]; then
        # On Windows, check if it's a wrapper script
        # Extract the version from the wrapper script by looking for exec command
        # The exec line contains the full path, so we need to extract just the binary name
        if grep -q "exec" "$gobin/go" 2>/dev/null; then
            local exec_line=$(grep "exec" "$gobin/go" 2>/dev/null | head -1)
            # Extract the go binary name from the path (handles both / and \ separators)
            default_symlink=$(echo "$exec_line" | sed 's|.*[/\\]||' | grep -o "go[0-9]\+\.[0-9]\+\.[0-9]\+" | head -1)
        fi
    fi
    
    # First, show the system default Go
    echo "System default Go:"
    echo "------------------"
    if command -v go >/dev/null 2>&1; then
        local default_version="unknown"
        local default_root="unknown"
        local default_path=$(which go 2>/dev/null || echo "unknown")
        
        # Only get version and GOROOT if go actually works
        if go version >/dev/null 2>&1; then
            default_version=$(go version 2>/dev/null || echo "unknown")
            default_root=$(go env GOROOT 2>/dev/null || echo "unknown")
        fi
        local is_default_marker=""
        
        # Check if this is the goverman-managed default
        if [[ "$default_path" == "$gobin/go" && -n "$default_symlink" ]]; then
            is_default_marker=" (goverman default → $default_symlink)"
        fi
        
        echo "  go$is_default_marker"
        echo "    Binary: $default_path"
        echo "    Version: $default_version"
        echo "    GOROOT: $default_root"
        echo ""
        found_versions=$((found_versions + 1))
    else
        echo "  No system Go installation found"
        echo ""
    fi
    
    # Now find additional Go versions
    # Handle broken Go installations
    local gopath="$HOME/go"
    local gobin_env=""
    if command -v go >/dev/null 2>&1 && go version >/dev/null 2>&1; then
        gopath=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
        gobin_env=$(go env GOBIN 2>/dev/null || echo "")
    fi
    
    # Build list of directories to check (remove duplicates)
    local search_dirs=()
    if [[ -n "$gobin_env" ]]; then
        search_dirs+=("$gobin_env")
    fi
    search_dirs+=("$gopath/bin")
    search_dirs+=("$HOME/go/bin")
    search_dirs+=("/usr/local/bin")
    search_dirs+=("$HOME/.local/bin")
    
    echo "Additional Go versions:"
    echo "----------------------"
    
    # Find go binaries, avoiding duplicates
    for dir in "${search_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            # Use find to handle Windows executable detection better
            while IFS= read -r binary; do
                if [[ -n "$binary" ]]; then
                    local version_name=$(basename "$binary")
                    # Remove .exe extension if present (Windows)
                    version_name="${version_name%.exe}"
                    if [[ "$version_name" =~ ^go[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        # Skip if we've already seen this version
                        if [[ " $seen_versions " == *" $version_name "* ]]; then
                            continue
                        fi
                        seen_versions="$seen_versions $version_name "
                        
                        local version_info=$("$binary" version 2>/dev/null || echo "unknown")
                        local goroot_info=$("$binary" env GOROOT 2>/dev/null || echo "unknown")
                        local default_marker=""
                        
                        # Check if this is the default
                        if [[ "$version_name" == "$default_symlink" ]]; then
                            default_marker=" [DEFAULT]"
                        fi
                        
                        echo "  $version_name$default_marker"
                        echo "    Binary: $binary"
                        echo "    Version: $version_info"
                        echo "    GOROOT: $goroot_info"
                        echo ""
                        found_versions=$((found_versions + 1))
                    fi
                fi
            done < <(find "$dir" -maxdepth 1 -name "go[0-9]*" -type f 2>/dev/null)
        fi
    done
    
    # Check for orphaned SDK installations (SDK without wrapper binary)
    if [[ -d "$HOME/sdk" ]]; then
        local orphaned_found=false
        
        for sdk_dir in "$HOME/sdk"/go[0-9]*; do
            if [[ -d "$sdk_dir" && -f "$sdk_dir/bin/go" ]]; then
                local version_name=$(basename "$sdk_dir")
                if [[ "$version_name" =~ ^go[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    # Check if we already found a binary for this version
                    if [[ " $seen_versions " != *" $version_name "* ]]; then
                        if [[ "$orphaned_found" == "false" ]]; then
                            echo "SDK installations without wrapper binaries:"
                            echo "-------------------------------------------"
                            orphaned_found=true
                        fi
                        
                        local version_info=$("$sdk_dir/bin/go" version 2>/dev/null || echo "unknown")
                        echo "  $version_name"
                        echo "    Location: $sdk_dir"
                        echo "    Version: $version_info"
                        echo "    ⚠️  No wrapper binary - not accessible as '$version_name'"
                        echo "    To create wrapper: ln -s $sdk_dir/bin/go ~/go/bin/$version_name"
                        echo ""
                        found_versions=$((found_versions + 1))
                    fi
                fi
            fi
        done
    fi
    
    echo "================================"
    echo "Total Go installations: $found_versions"
    echo ""
    
    if [[ $found_versions -gt 1 ]]; then
        echo "Usage:"
        echo "  go version               # Use system default"
        echo "  go1.21.5 version         # Use specific version"
        echo ""
        echo "To uninstall a version:"
        echo "  gman uninstall 1.21.5"
    else
        echo "To install additional Go versions:"
        echo "  gman install 1.23.9         # Install using official method"
        echo "  gman install 1.23.9 direct  # Install using direct method"
    fi
}

# Function to list available Go versions
list_available_versions() {
    # Check for --all flag
    local show_all=false
    if [[ "$1" == "--all" ]]; then
        show_all=true
    fi
    
    echo "Fetching available Go versions..."
    echo "================================="
    echo ""
    
    # Check if we have curl or wget
    local downloader=""
    if command -v curl >/dev/null 2>&1; then
        downloader="curl"
    elif command -v wget >/dev/null 2>&1; then
        downloader="wget"
    else
        echo "Error: Neither curl nor wget is available"
        echo "Cannot fetch version list from go.dev"
        return 1
    fi
    
    # Fetch the download page
    local temp_file=$(mktemp)
    local url="https://go.dev/dl/"
    
    echo "Fetching from: $url"
    echo ""
    
    local download_status=1
    if [[ "$downloader" == "curl" ]]; then
        if curl -sL "$url" > "$temp_file" 2>&1; then
            download_status=0
        fi
    else
        # wget exit code 5 = SSL verification error
        if wget -qO "$temp_file" "$url" 2>&1; then
            download_status=0
        else
            local wget_exit=$?
            if [[ $wget_exit -eq 5 ]]; then
                echo "SSL error detected, retrying with --no-check-certificate..."
                if wget --no-check-certificate -qO "$temp_file" "$url" 2>&1; then
                    download_status=0
                fi
            fi
        fi
    fi
    
    # Check if download succeeded and file has content
    if [[ $download_status -ne 0 ]] || [[ ! -s "$temp_file" ]]; then
        echo "Error: Failed to download version list from go.dev"
        if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]]; then
            echo "This often happens in CI environments due to network/SSL restrictions"
        fi
        rm -f "$temp_file"
        return 1
    fi
    
    # Parse versions from the HTML
    # Look for downloadBox entries and extract version numbers
    local versions=$(grep -oE 'go[0-9]+\.[0-9]+(\.[0-9]+)?' "$temp_file" | sort -Vr | uniq)
    
    if [[ -z "$versions" ]]; then
        echo "Error: Could not parse version list from downloaded content"
        if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]]; then
            echo "Debug: First 500 chars of downloaded content:"
            head -c 500 "$temp_file" | sed 's/^/  /'
        fi
        rm -f "$temp_file"
        return 1
    fi
    
    # Get current stable version (usually the first one)
    local stable_version=$(echo "$versions" | head -1)
    
    echo "Available Go versions:"
    echo "---------------------"
    
    # Display versions with markers
    local count=0
    while IFS= read -r version; do
        if [[ "$version" == "$stable_version" ]]; then
            echo "  $version (latest stable)"
        else
            echo "  $version"
        fi
        count=$((count + 1))
        
        # Show only first 20 versions by default unless --all is specified
        if [[ "$show_all" == "false" ]] && [[ $count -ge 20 ]]; then
            local remaining=$(echo "$versions" | wc -l)
            remaining=$((remaining - 20))
            if [[ $remaining -gt 0 ]]; then
                echo ""
                echo "  ... and $remaining more versions"
                echo ""
                echo "Note: Showing top 20 versions. Use 'gman list-available --all' to see all versions."
            fi
            break
        fi
    done <<< "$versions"
    
    rm -f "$temp_file"
    
    echo ""
    echo "Installation:"
    echo "------------"
    echo "To install a version, use:"
    echo "  gman install <version>         # Uses official method"
    echo "  gman install <version> direct  # Uses direct download"
    echo ""
    echo "Example:"
    echo "  gman install ${stable_version#go}"
}

# Function to safely remove directory
safe_remove_dir() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        # Additional safety check - make sure it's a Go directory
        if [[ "$dir" == *"/go"* ]] || [[ "$dir" == *"/sdk/go"* ]] || [[ -f "$dir/bin/go" ]]; then
            echo "Removing directory: $dir"
            rm -rf "$dir"
            echo "✓ Directory removed"
        else
            echo "Warning: Directory doesn't appear to be a Go installation: $dir"
            echo "Skipping removal for safety"
        fi
    else
        echo "Directory not found: $dir"
    fi
}

# Function to safely remove binary
safe_remove_binary() {
    local binary="$1"
    if [[ -f "$binary" ]]; then
        echo "Removing binary: $binary"
        rm -f "$binary"
        echo "✓ Binary removed"
    else
        echo "Binary not found: $binary"
    fi
}

# Function to check and handle default symlink
check_default_symlink() {
    local version="$1"
    local go_binary="go${version}"
    local gobin="$2"
    local go_link="$gobin/go"
    
    if [[ -L "$go_link" ]]; then
        local link_target=$(readlink "$go_link" | xargs basename)
        if [[ "$link_target" == "$go_binary" ]]; then
            echo ""
            echo "Warning: This version is currently set as the default 'go' command"
            echo "Removing the default symlink..."
            rm -f "$go_link"
            echo "✓ Default symlink removed"
            echo ""
            echo "Note: You'll need to set another version as default or the system Go will be used"
            echo "Run: gman set-default <version> to set a new default"
        fi
    fi
}

# Function to uninstall a Go version
uninstall_version() {
    local VERSION="$1"
    local GO_BINARY="go${VERSION}"
    
    echo "Uninstalling Go version ${VERSION}..."
    echo "======================================="
    
    # Step 1: Check if the go binary exists and get its GOROOT
    echo "Step 1: Checking for Go binary and getting GOROOT..."
    
    # Find the binary in common locations
    local BINARY_PATH=""
    local SEARCH_LOCATIONS=(
        "$HOME/go/bin/$GO_BINARY"
        "/usr/local/bin/$GO_BINARY"
        "$HOME/.local/bin/$GO_BINARY"
    )
    
    # Add GOBIN and GOPATH locations if Go is available
    if command -v go >/dev/null 2>&1; then
        local GOBIN_PATH=""
        local GOPATH_PATH="$HOME/go"
        
        # Only get env if Go is working
        if go version >/dev/null 2>&1; then
            GOBIN_PATH=$(go env GOBIN 2>/dev/null || echo "")
            GOPATH_PATH=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
        fi
        
        if [[ -n "$GOBIN_PATH" ]]; then
            SEARCH_LOCATIONS=("$GOBIN_PATH/$GO_BINARY" "${SEARCH_LOCATIONS[@]}")
        fi
        
        if [[ -n "$GOPATH_PATH" ]]; then
            SEARCH_LOCATIONS=("$GOPATH_PATH/bin/$GO_BINARY" "${SEARCH_LOCATIONS[@]}")
        fi
    fi
    
    # Search for the binary
    for location in "${SEARCH_LOCATIONS[@]}"; do
        if [[ -f "$location" ]]; then
            BINARY_PATH="$location"
            break
        fi
    done
    
    if [[ -z "$BINARY_PATH" ]]; then
        echo "Warning: Go binary '$GO_BINARY' not found in common locations"
        echo "Searched in:"
        for location in "${SEARCH_LOCATIONS[@]}"; do
            echo "  - $location"
        done
        echo ""
        echo "You may need to manually locate and remove the binary."
    else
        echo "Found binary: $BINARY_PATH"
        
        # Step 2: Get GOROOT from the binary
        echo ""
        echo "Step 2: Getting GOROOT..."
        
        if GOROOT_PATH=$("$BINARY_PATH" env GOROOT 2>/dev/null); then
            echo "GOROOT: $GOROOT_PATH"
            
            # Step 3: Remove the GOROOT directory
            echo ""
            echo "Step 3: Removing Go installation directory..."
            safe_remove_dir "$GOROOT_PATH"
        else
            echo "Warning: Could not get GOROOT from $GO_BINARY"
            echo "The Go installation directory may need to be removed manually."
        fi
        
        # Check if this version is set as default
        local GOBIN_DIR=$(dirname "$BINARY_PATH")
        check_default_symlink "$VERSION" "$GOBIN_DIR"
        
        # Step 4: Remove the binary
        echo ""
        echo "Step 4: Removing Go binary..."
        safe_remove_binary "$BINARY_PATH"
    fi
    
    echo ""
    echo "======================================="
    echo "Uninstallation process completed!"
    echo ""
    
    # Step 5: Verification
    echo "Step 5: Verification..."
    echo "Checking if $GO_BINARY is still accessible..."
    
    if command -v "$GO_BINARY" >/dev/null 2>&1; then
        echo "⚠️  Warning: $GO_BINARY is still accessible. You may need to:"
        echo "   - Check your PATH environment variable"
        echo "   - Restart your terminal"
        echo "   - Look for additional installations in other locations"
    else
        echo "✓ $GO_BINARY is no longer accessible"
    fi
    
    echo ""
    echo "Note: If you have multiple Go installations, make sure to check:"
    echo "  - /usr/local/go (system-wide installation)"
    echo "  - ~/go-versions/ (custom installations)"
    echo "  - Other custom installation directories"
}

# Function to uninstall all Go versions
uninstall_all() {
    echo "Uninstall All Go Versions"
    echo "========================="
    echo ""
    
    # Find all goverman-installed Go versions
    local found_versions=()
    local gopath=""
    local gobin_env=""
    
    # Handle broken Go installations
    if command -v go >/dev/null 2>&1 && go version >/dev/null 2>&1; then
        gopath=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
        gobin_env=$(go env GOBIN 2>/dev/null || echo "")
    else
        gopath="$HOME/go"
        gobin_env=""
    fi
    
    # Determine gobin
    local gobin
    if [[ -n "$gobin_env" ]]; then
        gobin="$gobin_env"
    else
        gobin="$gopath/bin"
    fi
    
    # Build list of directories to check
    local search_dirs=()
    if [[ -n "$gobin_env" ]]; then
        search_dirs+=("$gobin_env")
    fi
    search_dirs+=("$gopath/bin")
    search_dirs+=("$HOME/go/bin")
    search_dirs+=("/usr/local/bin")
    search_dirs+=("$HOME/.local/bin")
    
    # Find go binaries
    echo "Searching for goverman-installed Go versions..."
    echo ""
    
    for dir in "${search_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            while IFS= read -r binary; do
                if [[ -n "$binary" ]]; then
                    local version_name=$(basename "$binary")
                    # Remove .exe extension if present (Windows)
                    version_name="${version_name%.exe}"
                    if [[ "$version_name" =~ ^go[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        # Skip duplicates
                        local already_found=false
                        for v in "${found_versions[@]}"; do
                            if [[ "$v" == "$version_name" ]]; then
                                already_found=true
                                break
                            fi
                        done
                        if [[ "$already_found" == "false" ]]; then
                            found_versions+=("$version_name")
                        fi
                    fi
                fi
            done < <(find "$dir" -maxdepth 1 -name "go[0-9]*" -type f 2>/dev/null)
        fi
    done
    
    # Check if any versions were found
    if [[ ${#found_versions[@]} -eq 0 ]]; then
        echo "No goverman-installed Go versions found."
        echo ""
        echo "Note: This command only removes versions installed by gman."
        echo "System-wide Go installations in /usr/local/go are not affected."
        return 0
    fi
    
    # Display found versions
    echo "Found ${#found_versions[@]} goverman-installed Go version(s):"
    for version in "${found_versions[@]}"; do
        echo "  - $version"
    done
    echo ""
    
    # Check for default symlink
    local go_link="$gobin/go"
    local has_default=false
    if [[ -L "$go_link" ]] || ([[ -f "$go_link" ]] && grep -q "goverman" "$go_link" 2>/dev/null); then
        has_default=true
        echo "Note: Default 'go' command symlink will also be removed."
        echo ""
    fi
    
    # Confirm deletion
    if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ ! -t 0 ]]; then
        echo "Running in non-interactive mode (CI detected). Proceeding with uninstall."
        local confirm="y"
    else
        echo "⚠️  WARNING: This will permanently remove all goverman-installed Go versions!"
        read -p "Are you sure you want to uninstall ALL versions? (y/N): " -n 1 -r
        echo
        local confirm="$REPLY"
    fi
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Uninstall cancelled."
        return 0
    fi
    
    echo ""
    echo "Uninstalling all versions..."
    echo "============================"
    
    # Uninstall each version
    local success_count=0
    local fail_count=0
    
    for version_full in "${found_versions[@]}"; do
        # Extract version number (remove 'go' prefix)
        local version="${version_full#go}"
        echo ""
        echo "Uninstalling $version_full..."
        
        # Call the existing uninstall function
        if uninstall_version "$version" 2>&1 | sed 's/^/  /'; then
            success_count=$((success_count + 1))
        else
            echo "  ❌ Failed to uninstall $version_full"
            fail_count=$((fail_count + 1))
        fi
    done
    
    # Remove default symlink if it exists
    if [[ "$has_default" == "true" ]] && [[ -e "$go_link" ]]; then
        echo ""
        echo "Removing default 'go' symlink..."
        rm -f "$go_link"
        echo "✓ Default symlink removed"
    fi
    
    # Also check for orphaned SDK directories
    if [[ -d "$HOME/sdk" ]]; then
        local orphaned_count=0
        for sdk_dir in "$HOME/sdk"/go[0-9]*; do
            if [[ -d "$sdk_dir" ]]; then
                orphaned_count=$((orphaned_count + 1))
            fi
        done
        
        if [[ $orphaned_count -gt 0 ]]; then
            echo ""
            echo "Found $orphaned_count orphaned SDK director(ies) in $HOME/sdk"
            if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ ! -t 0 ]]; then
                local remove_sdk="y"
            else
                read -p "Remove orphaned SDK directories? (y/N): " -n 1 -r
                echo
                local remove_sdk="$REPLY"
            fi
            
            if [[ "$remove_sdk" =~ ^[Yy]$ ]]; then
                for sdk_dir in "$HOME/sdk"/go[0-9]*; do
                    if [[ -d "$sdk_dir" ]]; then
                        echo "Removing $sdk_dir..."
                        rm -rf "$sdk_dir"
                    fi
                done
                echo "✓ Orphaned SDK directories removed"
            fi
        fi
    fi
    
    echo ""
    echo "====================================="
    echo "Uninstall Summary"
    echo "====================================="
    echo "Successfully uninstalled: $success_count version(s)"
    if [[ $fail_count -gt 0 ]]; then
        echo "Failed to uninstall: $fail_count version(s)"
    fi
    echo ""
    
    if [[ $success_count -gt 0 ]]; then
        echo "✅ All goverman-installed Go versions have been removed."
    fi
    
    # Check if system Go is still available
    if command -v go >/dev/null 2>&1 && go version >/dev/null 2>&1; then
        echo ""
        echo "Note: System Go is still installed:"
        echo "  $(go version)"
        echo "  Location: $(which go)"
    else
        echo ""
        echo "No Go installation remains on this system."
        echo "To install Go again, use: gman bootstrap"
    fi
}

# Command: install
cmd_install() {
    # Save original PATH before any modifications
    export ORIGINAL_PATH="$PATH"
    
    local version="$1"
    local method="official"
    local set_default=false
    
    # Handle "latest" as a special version
    if [[ "$version" == "latest" ]]; then
        echo "Fetching latest Go version..."
        version=$(get_latest_go_version)
        if [[ $? -ne 0 ]] || [[ -z "$version" ]]; then
            echo "Error: Failed to fetch latest Go version"
            exit 1
        fi
        echo "Latest version is: $version"
        echo ""
    fi
    
    # Validate version format
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "Error: Invalid version format '$version'. Use format like '1.23.9' or 'latest'"
        exit 1
    fi
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            official|direct)
                method="$1"
                ;;
            --default)
                set_default=true
                ;;
            *)
                echo "Error: Unknown argument '$1'"
                show_usage
                ;;
        esac
        shift
    done
    
    echo "Go Version Installer"
    echo "==================="
    echo "Version: $version"
    echo "Method: $method"
    echo "Date: $(date)"
    echo ""
    
    # Check if Go is installed (only required for official method)
    if [[ "$method" == "official" ]]; then
        check_go_installed
    else
        # For direct method, just check if go command exists and warn if broken
        if command -v go >/dev/null 2>&1; then
            if go version >/dev/null 2>&1; then
                echo "✓ Go is installed: $(go version)"
            else
                echo "⚠️  Warning: Go command exists but is not working properly"
                echo "  The direct installation method will proceed anyway."
                echo ""
            fi
        else
            echo "Note: Go is not installed. Using direct installation method."
            echo ""
        fi
    fi
    
    # Check if version is already installed
    local go_binary="go${version}"
    if command -v "$go_binary" >/dev/null 2>&1; then
        echo "Warning: Go $version appears to be already installed"
        echo "Current installation: $($go_binary version)"
        echo "GOROOT: $($go_binary env GOROOT)"
        echo ""
        
        # Check if we're in CI/non-interactive mode
        if [[ -n "${CI:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ ! -t 0 ]]; then
            echo "Running in non-interactive mode (CI detected). Skipping reinstall." >&2
            echo "To force reinstall, first uninstall with: gman uninstall $version" >&2
            exit 0
        fi
        
        read -p "Do you want to reinstall? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Installation cancelled"
            exit 0
        fi
    fi
    
    # Install based on method
    case "$method" in
        "official")
            install_official "$version"
            ;;
        "direct")
            install_direct "$version"
            ;;
    esac
    
    # Verify installation
    verify_installation "$version"
    
    # Set as default if requested
    if [[ "$set_default" == "true" ]]; then
        echo ""
        echo "Setting as default Go version..."
        echo "================================"
        # Save the original PATH before it was modified by setup_go_path
        local original_path="${ORIGINAL_PATH:-$PATH}"
        PATH="$original_path" set_default_version "$version" "check_path"
    fi
}

# Main function
main() {
    # Check if no arguments provided
    if [[ $# -eq 0 ]]; then
        echo "Error: No command specified"
        echo ""
        show_usage
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        bootstrap)
            bootstrap_go "$@"
            ;;
        install)
            if [[ $# -eq 0 ]]; then
                echo "Error: No version specified for install"
                show_usage
            fi
            cmd_install "$@"
            ;;
        uninstall)
            if [[ $# -eq 0 ]]; then
                echo "Error: No version specified for uninstall"
                show_usage
            fi
            uninstall_version "$1"
            ;;
        uninstall-all)
            uninstall_all
            ;;
        list)
            list_installed_versions
            ;;
        list-available)
            list_available_versions "$@"
            ;;
        set-default)
            if [[ $# -eq 0 ]]; then
                echo "Error: No version specified for set-default"
                show_usage
            fi
            set_default_version "$1"
            ;;
        version|-v|--version)
            show_version
            ;;
        help|-h|--help)
            show_usage
            ;;
        *)
            echo "Error: Unknown command '$command'"
            echo ""
            show_usage
            ;;
    esac
}

# Run main function
main "$@"